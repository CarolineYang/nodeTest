// 62、不同路径
// 63、不同路径2-有障碍物
// 64、最短路径和
//53、最大子序和 dp[i] = Math.max(nums[i],dp[i-1]+nums[i])
//5、最长回文子串 dp[i][j]为slice(i,j+1)的字符串
//121、买卖股票的最佳时机
// 300、最长上升子序列 dp[i] = Math.max(dp[j]+1,dp[i])
// 354、俄罗斯套娃信封问题 题目关键排序（升序排width，同width降序）然后再最长上升子序列dp[i] = Math.max(dp[j]+1,dp[i])
//221、最大正方形 dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1
//42、接雨水 dp[i] = Math.min(rightMax,leftMax)-nums[i]  dp[i]之和即为所求  其实好像叫贪心算法

//dp[i][j] = dp[i-1][j]+dp[i][j-1]  第一行和第一列均为1


// 动态规划
//
// 动态规划是通过组合子问题来求解原问题的一种算法。
//动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。
// 这种情况下，动态规划算法对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了不必要的计算工作。
// 动态规划通常用来求解最优化问题。
//
// 　　设计一个动态规划算法通常可以分为四步
//
// 1、刻画一个最优解的特征值
// 2、递归定义最优解的值
// 3、计算最优解的值，通常采用自底向上的方法
// 4、利用计算出的信息构造出一个最优解
// 步骤1~3是动态规划算法求解问题的基础。如果我们仅仅需要一个最优解的值，而非解本身，可以忽略步骤4.如果确实需要步骤4，有时候需要在执行步骤3的过程中维护一些额外信息，以便用来构建一个最优解。
let b =3;
console.log(3 & b)

let a = {
    1:'1',
    2:'2',
    3:'2'
};
for(let key in a){
    if(key == 2){
        break;
    }
    console.log(key)
}


